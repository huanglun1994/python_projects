# -*- coding: utf-8 -*-
基本循环程序的时间复杂度：
0.基本操作，认为其时间复杂度为O（1）。如果是函数调用，应该将其时间复杂度代入，
  参与整体时间复杂度的计算。
1.加法规则（顺序复合）。如果算法（或所考虑算法片段）是两个部分（或多个部分）的顺序复合，
  其复杂性是这两部分（或多部分）的复杂性之和。以两个部分为例：
        T（n）=T1（n）+T2（n）=O（T1(n)）+O（T2(n)）=O（max（T1(n)，T2(n)））
  其中T1(n)和T2(n)分别为顺序复合的两个部分的时间复杂度。由于忽略了常亮因子，加法等价于求最大值，
  取T1(n)和T2(n)中复杂度较高的一个。
2.乘法规则（循环结构）。如果算法（或所考虑算法片段）是一个循环，循环体将执行T1(n)次，
  每次执行需要T2(n)时间，那么：
        T（n）=T1（n）*T2（n）=O（T1(n)）*O（T2(n)）=O（T1(n)*T2(n)）
3.取最大规则（分支结构）。如果算法（或所考虑算法片段）是条件分支，两个分支的时间复杂性分别为
  T1（n）和T2（n），则有：
        T（n）=O（max（T1(n)，T2(n)））

基本循环程序的例子
求两个n*n矩阵m1和m2的乘积，存入另一个n*n矩阵m。假设矩阵在Python语言里实现为两层的表，
两个参数矩阵已经有值，保存结果的m也准备好，计算过程描述如下：
for i in range(n):
    for j in range(n):
        x = 0.0
        for k in range(n):
            x = x + m1[i][k] * m2[k][j]
        m[i][j] = x
上例的时间复杂度为:T（n）=O（n）*O（n）*（O（1）+O（n）*O（1）+O（1））
                       =O（n）*O（n）*O（n）=O（n*n*n）=O（n^3）

另一个实例：求n阶方形矩阵的行列式的值，考虑两种算法。
高斯消元法：通过逐行消元，把原矩阵变换为一个上三角线矩阵，最后乘起所有对角线元素，就得到矩阵行列
式的值。
算法如下：
设被求值矩阵为二维表A[0:n][0:n]
for i in range(n-1):
    用A[i][i]将A[i+1:n][i]的值都变为0
det = 0.0
for i range(n):
    det += A[i][i]
最后求积的循环需要O(n)时间。前一步的消元循环从i等于0做到i等于n-2，对i迭代时需要n-i-1行的消元，在
每行对n-i个矩阵元素做乘法和减法运算，总的时间开销不超过O(n^2)，因此算法的时间复杂度是O(n^3)。

另一个算法：直接基于矩阵行列式的定义。这个算法是递归的，为计算n阶方阵的行列式时需要算出n个n-1阶的
行列式，没计算一个n-1阶行列式需要算出n-1个n-2阶的行列式，因此有下面推导：
            T(n)=n*((n-1)^2+T(n-1))>n*T(n-1)>n*(n-1)*T(n-2)>O(n!)
其中的平方项表示构造低阶矩阵的开销。复杂度O(n!)比O(n^2)增长得快得多，这个算法复杂度极高。